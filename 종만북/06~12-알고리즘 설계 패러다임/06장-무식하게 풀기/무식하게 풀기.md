### 무식하게 풀기

------

#### 1. 도입

무식하게 푸는 방식, 일명 전산학에서는 brute-force라고 하는데 컴퓨터의 빠른 계산 능력을 이용해 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법을 의미한다. 또한 가능한 방법을 전부 만들어보는 알고리즘을 완전탐색이라고 한다. 어떤 문제를 해결할때 가장 원초적으로 생각해 볼수 있는 방법이다.

#### 2. 재귀 호출과 완전탐색

**재귀함수** : 자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤 그 중 한 조각을 수행하고, 나머지를 자기 자신을 호출해 실행하는 함수를 가리킨다.

재귀 호출은 여러 알고리즘을 구현하는데 매우 유용하게 사용할 수 있는 도구이다.

예로 반복문을 재귀함수로 구현할수 있다.

```c
//1부터 n까지의 합을 계산하는 반복 함수와 재귀 함수

int sum(int n){
    int ret = 0;
    for(int i=1;i<=n;i++){
        ret+=i;
    }
    return ret;
}

int recursiveSum(int n){
    if(n==1)return 1;
    return n + recursiveSum(n-1);
}
```

**문제: 보글게임(BOGGLE)**

이 문제는 8방향으로 움직이면서 길이가 10인 단어를 5X5 배열에서 만들수 있는가를 판별하는 문제인데 이 문제를 완전탐색으로 풀게 될시 시간복잡도 O(8^10)이므로 시간이 초과된다. 이동할 때 어차피 안되는 곳은 탐색이 되지 않게 하여 한번 갔던곳을 다시 가지 않게 하는 방법을 사용하여 문제를 해결 할 수 있다.

**문제: 소풍(PICNIC)**

이 문제는 사람 두명이 짝을 짓고 다니게 하려고 하기위해 가능하게 할 수 있는 경우의 수를 구하는 것이 목표이다. 이때 (1,0)와 (0,1)은 같은 경우 이므로 이러한 중복이 나지 않게 하기 위해 재귀함수를 돌릴때 뒤로 가는 것을 방지해야 한다.

**문제: 게임판 덮기(BOARDCOVER)**

이 문제는 최대 20x20인 배열을 L자 모양의 블록으로 모두 덮을수 있나를 찾는 문제이다. 칸이 크지않으므로 경우의 수도 컴퓨터로 충분히 구할수 있는 수이다. 그러나 이때 주의 하여야 할것이 제일 왼쪽과 위쪽에 블럭을 놓을수 있고 비어있는 칸을 찾아 블럭을 놓을수 있는지 판별을하고 놓을때 빈칸을 찾는 반복문을 탈출해야 하는 것이다. 이 조건이 때문에 생각보다 걸렸다.

#### 3. 최적화 문제

 답이 하나가 아니라 여러개이고, 그 중에서 어떤 기준에 따라 가장 좋은 답을 찾아내는 문제들을 일컨다.

최적화 문제는 우리의 생활고 ㅏ아주 밀접하게 관려된어 있다. 인공지능, 생명공학, 자동차 디자인에 이르기까지 컴퓨터가 하는 많은 작업들이 최적화 문제로 표현된다.

대표적인 예

여행하는 외판원 문제 - 일명 tsp(traveling sales-man problem)이라고 한다. 여러 도시가 있는데 한도시에서 출발해 모든 도시를 거치고 다시 출발한 도시로 돌아오려고 할때 최소경로로 돌아오려고 하는 문제이다.

**문제: 시계 맞추기(CLOCKSYNC)**

