### 알고리즘의 시간 복잡도 분석

------

#### 1. 도입

좀더 빠른 알고리즘을 만들기 위해 첫번째로 하는것이 알고리즘의 속도 측성이다. 보통 수행 시간을 측정하는 기준은 반복문을 기준으로 시간을 측정한다. 그래서 **반복문이 지배한다고 봐도 과언이 아니다**. 

```c++
for(int i=1;i<=n;i++){
	for(int j=1;j<=n;j++){
		...
	}
}
```

이런 코드의 시간 복잡도는 n^2이다. 

#### 2. 선형 시간 알고리즘

**이동평균**: 주식의 가격, 연간 국내 총생산등 시간에 따라 변화하는 값들을 관찰할 때 유용하게 사용할 수 있는 통계적 기준이다.

n에 정비례하는 알고리즘

#### 3. 선형 시간 이하의 알고리즘

**이진탐색**: 배열A에서 어떤수 x를 찾으려고 할때 배열A의 수를 오름차순으로 정렬 해놓고 A[i-1]<x<A=[i]값이 될때i값이 x값이다.

#### 4. 다항 시간 알고리즘

변수 n과 n^2,n의거듭제곱들의 선형 결합으로 이루어진 식들을 다항식이라고 부른다. 반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 있는 알고리즘들을 다항 시간 알고리즘이라고 부른다.

#### 5. 시간 복잡도

**시간 복잡도**: 가장 널리 사용되는 알고리즘의 수행 시간 기준으로, 알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것이다.

**점근적 시간 표기: O표기**

**O 표기법(Big-O Notation)**:시간을 표기 할때 대문자 **O**를 사용한다.

대략적으로 함수의 상한을 나타낸다는데 그 의미가 있다.



#### 6. 수행 시간 어림짐작하기

**주먹구구 법칙**: 입력의 크기를 시간 복잡도에 대입해서 얻은 반복문 수행 횟수에 대해, 1초당 반복문 수행 횟수가 1억을 넘어가면 시간 제한을 초과할 가능성이 있다.



주먹구구 법칙은 그냥 어림짐작을 뿐으로 여러가지 고려사항들이 있다.

- 시간 복잡도가 프로그램의 실제 수행 속도를 반영하지 못하는 경우
- 반목분의 내부가 복잡한 경우
- 메모리 사용 패턴이 복잡한 경우
- 언어와 컴파일어의 차이
- 구형 컴퓨터를 사용하는 경우

**O(N)**: 크기가 1억6천인 입력까지 1초안에 풀수 있다. 

**O(N^2)**: 크기가 40960인 입력까지 1초안에 풀수 있다. 대략 16억

**O(N^3)**: 크기가 2560천만인 입력까지 1초안에 풀수 있다. 대략 160억

**O(NlogN)**: 크기가 2천만인 입력까지 1초안에 풀수 있다. 대략 5억

#### 7. 계산 복잡도 클래스: P,NP,NP-완비

**빠른 알고리즘** : 다항 시간 알고리즘이나 그보나 빠른 알고리즘들

**P문제** : 계산 복잡도 이론에서 다항시간 알고리즘이 존재하는 문제들의 집합

**계산 복잡도 클래스** : p문제처럼 같은 성질을 갖는 문제들을 모아놓은 집합

**환산**: 한문제를 다른 문제로 바꿔서 푸는 기법

**SAT문제**: 어려운 문제의 기준이 되는 것

**NP문제**: 답이 주어졌을때 이것이 정답인지를 다항 시간 내에 확인할 수 있는 문제

#### 8. 더읽을 거리

마스터 정리: 재귀적인 알고리즘의 시간 복잡도를 계산하는 쉬운 방법